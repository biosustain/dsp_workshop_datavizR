[["index.html", "Data Visualization in R Workshop material for 18th November 2025 1 Welcome", " Data Visualization in R Workshop material for 18th November 2025 1 Welcome Organisation: Data Science Platform Responsibles: Juliana Assis (jasge@dtu.dk)Andre Cunha (afecun@dtu.dk)Alberto Pallej√† Caro (apca@biosustain.dtu.dk) Welcome to the Data Visualization using R Workshop! This workshop introduces data visualization in R using the simplest ggplot2, plotly. We will cover both theory and practical exercises. Goals Understand R visualization grammar Produce publication-ready plots Explore real datasets Time Session ‚òï 9:00 ‚Äì 9:10 Hello, coffee, and setup üîÑ 9:10 ‚Äì 9:25 Introduction to Data Visualization üß© 9:25 ‚Äì 10:25 For Beginners: ggplot2 grammar ‚è∏Ô∏è 10:25 ‚Äì 10:40 Break üí¨ 10:40 ‚Äì 11:25 For Intermediate: plotly and markdown report (R Notebooks) ‚òï 11:25 ‚Äì 11:40 Short break ‚ôæÔ∏è 11:40 ‚Äì 12:30 For Advanced: The R Universe of tidyverse Below are two setup options to the pratical activities: Run the workshop in the cloud (no need to install anything). Launch the app: Run the workshop locally on your machine. To run it in your own machine install the following packages: # List of required CRAN packages packages &lt;- c( &quot;dplyr&quot;, &quot;ggplot2&quot;, &quot;ggrepel&quot;, &quot;RColorBrewer&quot;, &quot;rmarkdown&quot;, &quot;tidyr&quot;, &quot;plotly&quot; ) # Install missing packages install_if_missing &lt;- function(pkg) { if (!requireNamespace(pkg, quietly = TRUE)) { install.packages(pkg, repos = &quot;https://cloud.r-project.org/&quot;) } else { message(pkg, &quot; already installed.&quot;) } } # Run installation invisible(lapply(packages, install_if_missing)) message(&quot;All requested R packages are installed and ready to use!&quot;) Slides Local build of website options(error = traceback) bookdown::render_book(&quot;index.Rmd&quot;, &quot;bookdown::gitbook&quot;) "],["for-beginners.html", "2 For beginners", " 2 For beginners Excerpt adapted from: Hadley Wickham, Danielle Navarro, and Thomas Lin Pedersen. ggplot2: Elegant Graphics for Data Analysis (3rd edition). Online version available at https://ggplot2-book.org. Source code: https://github.com/hadley/ggplot2-book. Copyright ¬© Springer Nature and the authors. Used here for educational purposes under fair use. ggplot2 is an R package for producing visualizations of data. ggplot2 uses a conceptual framework based on the grammar of graphics. More complete information about how to use ggplot2 can be found in the book. For structure, we go over the 7 composable parts that come together as a set of instructions on how to draw a chart. gplot2 needs at least the following three to produce a chart: data, a mapping, and a layer. The scales, facets, coordinates, and themes have sensible defaults that take away a lot of finicky work. In this tutorial you‚Äôll learn: About the mpg dataset included with ggplot2 The three key components of every plot: data, aesthetics and geoms How to add additional variables to a plot with aesthetics How to display additional categorical variables in a plot using small multiples created by faceting A variety of different geoms that you can use to create different types of plots How to modify the axes Save the Plot "],["data.html", "2.1 Data", " 2.1 Data As the foundation of every graphic, ggplot2 uses data to construct a plot. The system works best if the data is provided in a tidy format (we‚Äôre going to explorer it in the next section), which briefly means a rectangular data frame structure where rows are observations and columns are variables. As the first step in many plots, you would pass the data to the ggplot() function, which stores the data to be used later by other parts of the plotting system. For example, if we intend to make a graphic about the mpg dataset, we would start as follows: üìå Remember: Load the library before starting the analysis. library(ggplot2) mpg ## # A tibble: 234 √ó 11 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 1.8 1999 4 auto‚Ä¶ f 18 29 p comp‚Ä¶ ## 2 audi a4 1.8 1999 4 manu‚Ä¶ f 21 29 p comp‚Ä¶ ## 3 audi a4 2 2008 4 manu‚Ä¶ f 20 31 p comp‚Ä¶ ## 4 audi a4 2 2008 4 auto‚Ä¶ f 21 30 p comp‚Ä¶ ## 5 audi a4 2.8 1999 6 auto‚Ä¶ f 16 26 p comp‚Ä¶ ## 6 audi a4 2.8 1999 6 manu‚Ä¶ f 18 26 p comp‚Ä¶ ## 7 audi a4 3.1 2008 6 auto‚Ä¶ f 18 27 p comp‚Ä¶ ## 8 audi a4 quat‚Ä¶ 1.8 1999 4 manu‚Ä¶ 4 18 26 p comp‚Ä¶ ## 9 audi a4 quat‚Ä¶ 1.8 1999 4 auto‚Ä¶ 4 16 25 p comp‚Ä¶ ## 10 audi a4 quat‚Ä¶ 2 2008 4 manu‚Ä¶ 4 20 28 p comp‚Ä¶ ## # ‚Ñπ 224 more rows üí° Tip: You can use the command View to visualize the data. Try it yourself. View(mpg) üß† Advanced: DT package is an excellent option to explore the metadata! Try it yourself. Simple library(DT) datatable(head(mpg), class = &#39;cell-border stripe&#39;) Complex mpg includes information about the fuel economy of popular car models in 1999 and 2008, collected by the US Environmental Protection Agency The variables are mostly self-explanatory: cty and hwy record miles per gallon (mpg) for city and highway driving. displ is the engine displacement in litres. drv is the drivetrain: front wheel (f), rear wheel (r) or four wheel (4). model is the model of car. There are 38 models, selected because they had a new edition every year between 1999 and 2008. class is a categorical variable describing the ‚Äútype‚Äù of car: two seater, SUV, compact, etc. üìò Note: You can list all the data available in ggplot with tthe following command: data(package = &quot;ggplot2&quot;) This dataset suggests many interesting questions. -How are engine size and fuel economy related? -Do certain manufacturers care more about fuel economy than others? -Has fuel economy improved in the last ten years? We will try to answer some of these questions, and in the process learn how to create some basic plots with ggplot2. üìå Remember: Data visualization is a way to tell the story of your data. 2.1.1 Understanding the grammar of the plots data ggplot(data = mpg) ‚ùì Question: Why is it empty? 2.1.2 Mapping - Aesthetic The mapping of a plot is a set of instructions on how parts of the data are mapped onto aesthetic attributes of geometric objects. It is the ‚Äòdictionary‚Äô to translate tidy data to the graphics system. A mapping can be made by using the aes() function to make pairs of graphical attributes and parts of the data. If we want the cty and hwy columns to map to the x- and y-coordinates in the plot, we can do that as follows: ggplot(mpg, mapping = aes(x = cty, y = hwy)) 2.1.3 Layers The heart of any graphic is the layers. They take the mapped data and display it in something humans can understand as a representation of the data. Every layer consists of three important parts: The geometry that determines how data are displayed, such as points, lines, or rectangles. The statistical transformation that may compute new variables from the data and affect what of the data is displayed. The position adjustment that primarily determines where a piece of data is being displayed. A layer can be constructed using the geom_() and stat_() functions. These functions often determine one of the three parts of a layer, while the other two can still be specified. Here is how we can use two layers to display the cty and hwy columns of the mpg dataset as points and stack a trend line on top. Here‚Äôs a simple example: ggplot(mpg, aes(x = displ, y = hwy)) + geom_point() This produces a scatterplot defined by: Data: mpg. Aesthetic mapping: engine size mapped to x position, fuel economy to y position. Layer: points. Pay attention to the structure of this function call: data and aesthetic mappings are supplied in ggplot(), then layers are added on with +. ‚≠ê Important: + is an important pattern to learn This is an important pattern, and as you learn more about ggplot2 you‚Äôll construct increasingly sophisticated plots by adding on more types of components. Almost every plot maps a variable to x and y, so naming these aesthetics is tedious, so the first two unnamed arguments to aes() will be mapped to x and y. This means that the following code is identical to the example above: ggplot(mpg, aes(displ, hwy)) + geom_point() üí° Tip: Don‚Äôt forget that the first two arguments to aes() are x and y. üìò Note: Note that we‚Äôve put each command on a new line. We recommend doing this in your own code, so it‚Äôs easy to scan a plot specification and see exactly what‚Äôs there. The plot shows a strong correlation: as the engine size gets bigger, the fuel economy gets worse. There are also some interesting outliers: some cars with large engines get higher fuel economy than average. ‚ùì Question: What sort of cars do you think they are? 2.1.4 Labs labs() in ggplot2 The labs() function sets or updates text labels in your plot, including the title, subtitle, caption, axis labels, and legend labels (for aesthetics like color, shape, or size). Why it‚Äôs important: Clear and informative labels help the audience quickly understand what the plot shows, what each axis represents, and what the different colors or shapes mean. Well-labeled plots are easier to interpret and communicate your data effectively. Figure 2.1: Credit: xkcd.com/833 ggplot(mpg, aes(displ, hwy)) + geom_point() + labs( title = &quot;Engine Size vs Highway Fuel Efficiency&quot;, x = &quot;Engine Displacement (litres)&quot;, y = &quot;Highway (mpg)&quot;, caption = &quot;mpg dataset, ggplot&quot; ) "],["colour-size-shape-and-other-aesthetic-attributes.html", "2.2 Colour, size, shape and other aesthetic attributes", " 2.2 Colour, size, shape and other aesthetic attributes To add additional variables to a plot, we can use other aesthetics like colour, shape, and size üí° Extra: ggplot2 accepts American and British spellings These work in the same way as the x and y aesthetics, and are added into the call to aes(): aes(displ, hwy, colour = class) aes(displ, hwy, shape = drv) aes(displ, hwy, size = cyl) ggplot2 takes care of the details of converting data (e.g., ‚Äòf‚Äô, ‚Äòr‚Äô, ‚Äò4‚Äô) into aesthetics (e.g., ‚Äòred‚Äô, ‚Äòyellow‚Äô, ‚Äògreen‚Äô) with a scale. üìò Note: ‚Äòf‚Äô ‚Äì a single character, ‚Äòr‚Äô ‚Äì another character, ‚Äò4‚Äô ‚Äì a character that looks like a number but is still stored as text, not numeric. There is one scale for each aesthetic mapping in a plot. The scale is also responsible for creating a guide, an axis or legend, that allows you to read the plot, converting aesthetic values back into data values. For now, we‚Äôll stick with the default scales provided by ggplot2. To learn more about those outlying variables in the previous scatterplot, we could map the class variable to colour: ggplot(mpg, aes(displ, hwy, colour = class)) + geom_point() This gives each point a unique colour corresponding to its class. The legend allows us to read data values from the colour, showing us that the group of cars with unusually high fuel economy for their engine size are two seaters: cars with big engines, but lightweight bodies. If you want to set an aesthetic to a fixed value, without scaling it, do so in the individual layer outside of aes(). Compare the following two plots: ggplot(mpg, aes(displ, hwy)) + geom_point(aes(colour = &quot;blue&quot;)) ggplot(mpg, aes(displ, hwy)) + geom_point(colour = &quot;blue&quot;) In the first plot, the value blue is scaled to a pinkish colour, and a legend is added. In the second plot, the points are given the R colour blue . This is an important technique and you‚Äôll learn more about it in mapping for the values needed for colour and other aesthetics. Different types of aesthetic attributes work better with different types of variables. üí° Tip: colour and shape work well with categorical variables, while size works well for continuous variables. Categorical vs Continuous in the mpg dataset Aesthetic Works Best For Example mpg Variables colour (discrete) Categorical class, drv, cyl shape Categorical drv, fl facets Categorical class, year colour (gradient) Continuous displ, hwy, cty size Continuous displ, hwy The amount of data also makes a difference: if there is a lot of data it can be hard to distinguish different groups. An alternative solution is to use faceting, as described next. It‚Äôs difficult to see the simultaneous relationships among colour andshape and size, so exercise restraint when using aesthetics. Instead of trying to make one very complex plot that shows everything at once, see if you can create a series of simple plots that tell a story, leading the reader from ignorance to knowledge. üìå Remember: When using aesthetics in a plot, less is usually more. üí° üöó Categorical variables (factor / discrete), üìà Continuous (numeric) variables. 2.2.1 Using labs() together with colors ggplot(mpg, aes(displ, hwy, color = class)) + geom_point() + labs( title = &quot;Engine Size vs Highway Fuel Efficiency&quot;, subtitle = &quot;Colored by vehicle class&quot;, x = &quot;Engine Displacement (litres)&quot;, y = &quot;Highway (mpg)&quot;, color = &quot;Vehicle Class&quot;, caption = &quot;mpg dataset, ggplot&quot; ) 2.2.2 Exercises Experiment with the colour, shape and size aesthetics. -What happens when you map them to continuous values? -What about categorical values? -What happens when you use more than one aesthetic in a plot? What happens if you map a continuous variable to shape? -Why? -What happens if you map trans to shape? -Why? 2.2.3 Small hint ggplot(mpg, aes(x = displ, y = hwy, colour = class, # categorical size = displ)) + # continuous geom_point(alpha = 0.8) + scale_size_continuous(range = c(2, 8)) + labs( title = &quot;Engine Size vs Highway Efficiency&quot;, subtitle = &quot;Colour = vehicle class (categorical), Size = engine displacement (continuous)&quot;, x = &quot;Engine displacement (L)&quot;, y = &quot;Highway MPG&quot;, colour = &quot;Vehicle Class&quot;, size = &quot;Displ&quot; ) + theme_pubr(border = FALSE) "],["facets.html", "2.3 Facets", " 2.3 Facets Facets can be used to separate small multiples, or different subsets of the data. It is a powerful tool to quickly split up the data into smaller panels, based on one or more variables, to display patterns or trends (or the lack thereof) within the subsets. The facets have their own mapping that can be given as a formula. To plot subsets of the mpg dataset based on levels of the drv and year variables, we can use facet_grid() as follows: ggplot(mpg, aes(cty, hwy)) + geom_point() + facet_grid(year ~ drv) ggplot(mpg, aes(displ, hwy)) + geom_point() + facet_wrap(~class) You might wonder when to use faceting and when to use aesthetics. You‚Äôll learn more about the relative advantages and disadvantages of each in group-vs-facet 2.3.1 Exercises What happens if you try to facet by a continuous variable like hwy? What about cyl? What‚Äôs the key difference? Use faceting to explore the 3-way relationship between fuel economy, engine size, and number of cylinders. How does faceting by number of cylinders change your assessement of the relationship between engine size and fuel economy? Read the documentation for facet_wrap(). What arguments can you use to control how many rows and columns appear in the output? What does the scales argument to facet_wrap() do? When might you use it? "],["coordinates---plot-geoms.html", "2.4 Coordinates - Plot geoms", " 2.4 Coordinates - Plot geoms Coordinates define how data values are mapped to positions on the plot. The Cartesian system is the default (x‚Äìy axes), but ggplot2 also supports: Map projections (for geographic data) Polar coordinates (useful for circular plots) You can also control the aspect ratio of a plot: Use coord_fixed() to make one unit on x equal one unit on y. This is helpful when comparing scales like city vs highway mpg so distances are proportional. Example: ggplot(mpg, aes(cty, hwy)) + geom_point() + coord_fixed() Now, a 45-degree line would correctly indicate equal city and highway mpg, which is easier to interpret visually. Without coord_fixed(), the default plot might stretch one axis, misleading the viewer about relative differences. ‚ùì What would the plot look like if coord_fixed() was not used?, or changed to 90? Try it out! üìò Note: Coordinates control how data values are positioned on the plot. coord_fixed() ensures that one unit on the x-axis is the same length as one unit on the y-axis, making comparisons easier and more accurate. "],["geom_point.html", "2.5 geom_point()", " 2.5 geom_point() You might guess that by substituting geom_point() for a different geom function, you‚Äôd get a different type of plot. That‚Äôs a great guess! In the following sections, you‚Äôll learn about some of the other important geoms provided in ggplot2. This isn‚Äôt an exhaustive list, but should cover the most commonly used plot types. geom_smooth() fits a smoother to the data and displays the smooth and its standard error. geom_boxplot() produces a box-and-whisker plot to summarise the distribution of a set of points. geom_histogram() and geom_freqpoly() show the distribution of continuous variables. geom_bar() shows the distribution of categorical variables. geom_path() and geom_line() draw lines between the data points. A line plot is constrained to produce lines that travel from left to right, while paths can go in any direction. Lines are typically used to explore how things change over time. "],["sec-boxplot.html", "2.6 Boxplots and jittered points", " 2.6 Boxplots and jittered points When a set of data includes a categorical variable and one or more continuous variables, you will probably be interested to know how the values of the continuous variables vary with the levels of the categorical variable. Say we‚Äôre interested in seeing how fuel economy varies within cars that have the same kind of drivetrain. We might start with a scatterplot like this: ggplot(mpg, aes(drv, hwy)) + geom_point() Because there are few unique values of both drv and hwy, there is a lot of overplotting. Many points are plotted in the same location, and it‚Äôs difficult to see the distribution. There are three useful techniques that help alleviate the problem: Jittering, geom_jitter(), adds a little random noise to the data which can help avoid overplotting. Boxplots, geom_boxplot(), summarise the shape of the distribution with a handful of summary statistics. Violin plots, geom_violin(), show a compact representation of the ‚Äúdensity‚Äù of the distribution, highlighting the areas where more points are found. Each method has its strengths and weaknesses. Boxplots summarise the bulk of the distribution with only five numbers, while jittered plots show every point but only work with relatively small datasets. Violin plots give the richest display, but rely on the calculation of a density estimate, which can be hard to interpret. For jittered points, geom_jitter() offers the same control over aesthetics as geom_point(): size, colour, and shape. For geom_boxplot() and geom_violin(), you can control the outline colour or the internal fill colour. 2.6.1 Exercises Can you reproduce the graphics bellow? Can you make it better, adding colors for ex? "],["sec-distribution.html", "2.7 Histograms and frequency polygons", " 2.7 Histograms and frequency polygons Histograms and frequency polygons show the distribution of a single numeric variable. They provide more information about the distribution of a single group than boxplots do, at the expense of needing more space. ggplot(mpg, aes(hwy)) + geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ggplot(mpg, aes(hwy)) + geom_freqpoly() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Both histograms and frequency polygons work in the same way: they bin the data, then count the number of observations in each bin. The only difference is the display: histograms use bars and frequency polygons use lines. You can control the width of the bins with the binwidth argument (if you don‚Äôt want evenly spaced bins you can use the breaks argument). It is very important to experiment with the bin width. The default just splits your data into 30 bins, which is unlikely to be the best choice. You should always try many bin widths, and you may find you need multiple bin widths to tell the full story of your data. ggplot(mpg, aes(hwy)) + geom_freqpoly(binwidth = 2.5) ggplot(mpg, aes(hwy)) + geom_freqpoly(binwidth = 1) An alternative to the frequency polygon is the density plot, geom_density(). A little care is required if you‚Äôre using density plots: compared to frequency polygons they are harder to interpret since the underlying computations are more complex. They also make assumptions that are not true for all data, namely that the underlying distribution is continuous, unbounded, and smooth. To compare the distributions of different subgroups, you can map a categorical variable to either fill (for geom_histogram()) or colour (for geom_freqpoly()). It‚Äôs easier to compare distributions using the frequency polygon because the underlying perceptual task is easier. You can also use faceting: this makes comparisons a little harder, but it‚Äôs easier to see the distribution of each group. ggplot(mpg, aes(displ, colour = drv)) + geom_freqpoly(binwidth = 0.5) ggplot(mpg, aes(displ, fill = drv)) + geom_histogram(binwidth = 0.5) + facet_wrap(~drv, ncol = 1) "],["exercises-3.html", "2.8 Exercises", " 2.8 Exercises What‚Äôs the problem with the plot created by ggplot(mpg, aes(cty, hwy)) + geom_point()? Which of the geoms that we learned is most effective at remedying the problem? One challenge with ggplot(mpg, aes(class, hwy)) + geom_boxplot() is that the ordering of class is alphabetical, which is not terribly useful. How could you change the factor levels to be more informative? Rather than reordering the factor by hand, you can do it automatically based on the data: ggplot(mpg, aes(reorder(class, hwy), hwy)) + geom_boxplot(). What does reorder() do? Read the documentation. "],["commenting-the-answers.html", "2.9 Commenting the answers", " 2.9 Commenting the answers Overlapping points problem # Original plot ‚Äì points overlap ggplot(mpg, aes(cty, hwy)) + geom_point() + labs(title = &quot;City vs Highway MPG (overlapping points)&quot;) Problem: Many cars have the same cty and hwy values ‚Üí points overlap ‚Üí hard to see density. Solutions: # Option 1: jitter points slightly ggplot(mpg, aes(cty, hwy)) + geom_jitter(width = 0.2, height = 0.2) + labs(title = &quot;City vs Highway MPG (jittered)&quot;) # Option 2: size points by count ggplot(mpg, aes(cty, hwy)) + geom_count() + labs(title = &quot;City vs Highway MPG (point size = count)&quot;) üí° Tip: geom_jitter() or geom_count() helps visualize overlapping points effectively. Boxplot with alphabetically ordered classes ggplot(mpg, aes(class, hwy)) + geom_boxplot() + labs(title = &quot;Highway MPG by Vehicle Class (alphabetical order)&quot;) Problem: class is ordered alphabetically ‚Üí not informative Example: ‚Äú2seater‚Äù appears first, ‚Äúsuv‚Äù last, regardless of MPG values. Reordering factor by data # Reorder class by median highway MPG ggplot(mpg, aes(reorder(class, hwy, FUN = median), hwy)) + geom_boxplot() + labs( x = &quot;Vehicle Class (ordered by median hwy MPG)&quot;, title = &quot;Highway MPG by Vehicle Class (reordered)&quot; ) Explanation: reorder(class, hwy, FUN = median) ‚Üí sorts class on the x-axis by median highway mpg Makes the plot more informative: easy to compare classes from low to high mpg üí° Tip: Always consider data-driven factor ordering for categorical variables in plots. "],["theme.html", "2.10 Theme", " 2.10 Theme The theme system controls almost any visuals of the plot that are not controlled by the data and is therefore important for the look and feel of the plot. You can use the theme for customizations ranging from changing the location of the legends to setting the background color of the plot. Many elements in the theme are hierarchical in that setting the look of the general axis line affects those of the x and y axes simultaneously. To tweak the look of the plot, one can use many of the built-in theme_() functions and/or detail specific aspects with the theme() function. The element_() functions control the graphical attributes of theme components. ggplot(mpg, aes(cty, hwy, colour = class)) + geom_point() + theme_minimal() + theme( legend.position = &quot;top&quot;, axis.line = element_line(linewidth = 0.75), axis.line.x.bottom = element_line(colour = &quot;blue&quot;) ) "],["combining.html", "2.11 Combining", " 2.11 Combining As mentioned at the start, you can layer all of the pieces to build a customized plot of your data, like the one shown at the beginning of this vignette: ggplot(mpg, aes(cty, hwy)) + geom_point(mapping = aes(colour = displ)) + geom_smooth(formula = y ~ x, method = &quot;lm&quot;) + scale_colour_viridis_c() + facet_grid(year ~ drv) + coord_fixed() + theme_minimal() + theme(panel.grid.minor = element_blank()) "],["adding-a-smoother-to-a-plot.html", "2.12 Adding a smoother to a plot", " 2.12 Adding a smoother to a plot If you have a scatterplot with a lot of noise, it can be hard to see the dominant pattern. In this case it‚Äôs useful to add a smoothed line to the plot with geom_smooth(): ggplot(mpg, aes(displ, hwy)) + geom_point() + geom_smooth() ## `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39; This overlays the scatterplot with a smooth curve, including an assessment of uncertainty in the form of point-wise confidence intervals shown in grey. If you‚Äôre not interested in the confidence interval, turn it off with geom_smooth(se = FALSE). An important argument to geom_smooth() is the method, which allows you to choose which type of model is used to fit the smooth curve: method = \"loess\", the default for small n, uses a smooth local regression. The wiggliness of the line is controlled by the span parameter, which ranges from 0 (exceedingly wiggly) to 1 (not so wiggly). ggplot(mpg, aes(displ, hwy)) + geom_point() + geom_smooth(span = 0.2) ## `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39; ggplot(mpg, aes(displ, hwy)) + geom_point() + geom_smooth(span = 1) ## `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39; Loess does not work well for large datasets (it‚Äôs \\(O(n^2)\\) in memory), so an alternative smoothing algorithm is used when \\(n\\) is greater than 1,000. method = \"gam\" fits a generalised additive model provided by the mgcv package. You need to first load mgcv, then use a formula like formula = y ~ s(x) or y ~ s(x, bs = \"cs\") (for large data). This is what ggplot2 uses when there are more than 1,000 points. library(mgcv) ggplot(mpg, aes(displ, hwy)) + geom_point() + geom_smooth(method = &quot;gam&quot;, formula = y ~ s(x)) method = \"lm\" fits a linear model, giving the line of best fit. ‚ùì Question: Can you make a plot using ‚Äúlm‚Äù? ## `geom_smooth()` using formula = &#39;y ~ x&#39; 2.12.1 Combining ggplot(mpg, aes(displ, hwy)) + geom_point() + geom_smooth(aes(colour = &quot;loess&quot;), method = &quot;loess&quot;, se = FALSE) + geom_smooth(aes(colour = &quot;lm&quot;), method = &quot;lm&quot;, se = FALSE) + labs(colour = &quot;Method&quot;) ## `geom_smooth()` using formula = &#39;y ~ x&#39; ## `geom_smooth()` using formula = &#39;y ~ x&#39; "],["exercises-4.html", "2.13 Exercises", " 2.13 Exercises Simplify the following plot specifications: ggplot(mpg) + geom_point(aes(mpg$displ, mpg$hwy)) ggplot() + geom_point(mapping = aes(y = hwy, x = cty), data = mpg) + geom_smooth(data = mpg, mapping = aes(cty, hwy)) "],["for-intermediate.html", "3 For Intermediate", " 3 For Intermediate üìä Interactive Plots in R: plotly and ggplotly Interactive figures are extremely useful during data exploration and dashboards. In this section, we introduce two approaches for interactivity: ggplotly() ‚Äî convert an existing ggplot2 plot into an interactive widget plotly ‚Äî build interactive plots directly using Plotly‚Äôs own grammar 3.0.1 ‚≠ê ggplotly(): Add Interactivity to an Existing ggplot ggplotly() is a converter. It takes a normal ggplot2 object and transforms it into an interactive Plotly plot, with zooming, panning, hovering, and tooltips. ‚úî When to use ggplotly() Use it when: You already have a ggplot and want to enhance it with interactivity. You want to keep your ggplot aesthetics, including: facet_wrap themes (theme_minimal(), theme_pubr(), etc.) fill, color, and shape aesthetics scales and labels You want a quick, simple solution with minimal code changes. üîß Example library(plotly) p &lt;- ggplot(mpg, aes(displ, hwy, color = class)) + geom_point(size = 3) + labs( title = &quot;Engine Size vs Highway MPG&quot;, x = &quot;Displacement&quot;, y = &quot;Highway mileage&quot; ) + theme_minimal() ggplotly(p) ‚ú® Output Interactive scatter plot Hover tooltips Zooming, box selection, and legend toggling Looks almost identical to your original ggplot 3.0.2 ‚≠ê Plotly (native): Build Interactive Plots Directly Plotly also has its own plotting grammar using plot_ly(). This approach offers more control and more interactivity than converting from ggplot. ‚úî When to use native plotly Use it when: You‚Äôre creating dashboards (Shiny, Quarto). You want advanced interactivity You need performance with large datasets. üîß Example plot_ly( data = mpg, x = ~displ, y = ~hwy, color = ~class, type = &quot;scatter&quot;, mode = &quot;markers&quot; ) 3.0.3 Exercises Using the built-in mpg dataset: Make a histogram of hwy (highway fuel efficiency). Fill the bars by class. Use 30 bins. Add a title: ‚ÄúHighway Mileage Distribution‚Äù Apply theme_minimal(). Convert your ggplot object into an interactive figure with ggplotly(). Maybe you can also try facet_wrap(~year). Try to re-plot some plots we‚Äôve learned before. You can also compare it to native plotly "],["real-data.html", "3.1 Real data", " 3.1 Real data Inspecting and summarizing the proteomics data. library(readr) library(plotly) library(tidyverse) üìå Remember: Load the library before starting the analysis. Load and prepare the data read_csv = reads a csv file data &lt;- read_csv(&quot;../data-01/PXD040621_peptides.csv&quot;, show_col_types = FALSE) üìå Remember: Remember: You can use the DT package to visualize the data. DT::datatable( data = head(data, 1000), # show only the first 1000 rows rownames = FALSE, extensions = c(&#39;Buttons&#39;, &#39;Scroller&#39;), options = list( dom = &#39;Bfrtip&#39;, buttons = c(&#39;copy&#39;, &#39;csv&#39;), deferRender = TRUE, scrollX = TRUE, scrollY = 200, scroller = TRUE ), caption = &#39;proteomics metadata&#39; ) How to load a R object protein_data_parsed &lt;- readRDS(&quot;../data-01/protein_data_parsed_mut.rds&quot;) library(plotly) p &lt;- ggplot(protein_data_parsed, aes(x = Intensity, fill = Label)) + geom_histogram(bins = 40, color = &quot;white&quot;) + theme_minimal() + facet_wrap(~Reference, scales = &quot;fixed&quot;, nrow = 2) ggplotly(p) plot_ly( data = protein_data_parsed, x = ~Intensity, color = ~Reference, # equivalent to fill in ggplot2 type = &quot;histogram&quot; ) %&gt;% layout( barmode = &quot;stack&quot;, # &quot;overlay&quot; or &quot;stack&quot; title = &quot;Protein Intensity Distribution by Label&quot;, xaxis = list(title = &quot;Intensity&quot;), yaxis = list(title = &quot;Count&quot;) ) "],["for-advanced.html", "4 For Advanced", " 4 For Advanced Here we will use the tidyverse package to transform, clean, and visualize the proteomics data, producing high-quality, publication-ready figures throughout the analysis. "],["data-preparation.html", "4.1 Data preparation", " 4.1 Data preparation 4.1.1 Loading the raw proteomics data üìå Remember: Load the library before starting the analysis. library(tidyverse) Load and prepare the data. read_csv() from readr package (part of tidyverse) is used to read csv files. data &lt;- read_csv(&quot;../data-01/PXD040621_peptides.csv&quot;, show_col_types = FALSE) üìå Remember: Remember: You can use the DT package to visualize the data. DT::datatable( data = head(data, 1000), # show only the first 1000 rows rownames = FALSE, extensions = c(&quot;Buttons&quot;, &quot;Scroller&quot;), options = list( dom = &quot;Bfrtip&quot;, buttons = c(&quot;copy&quot;, &quot;csv&quot;), deferRender = TRUE, scrollX = TRUE, scrollY = 200, scroller = TRUE ), caption = &quot;proteomics metadata&quot; ) 4.1.2 Data transformation log2 transformations are commonly used for log-normal distributed data. data &lt;- data %&gt;% mutate(Intensity = log2(Intensity)) ‚ùì Question: Do you remember what the %&gt;% (pipe) is doing in the code? 4.1.3 Data aggregation Let‚Äôs aggregate the peptide intensities to protein intensities. We use the median of the peptide intensities for each protein. Also, let‚Äôs shorten sample names for better readability. protein_data &lt;- data %&gt;% group_by(ProteinName, Reference) %&gt;% summarize(Intensity = median(Intensity, na.rm = TRUE), .groups = &quot;drop&quot;) %&gt;% # Small pipeline to shorten Reference names mutate(Reference_parts = strsplit(Reference, &quot;_&quot;)) %&gt;% mutate(Reference_parts = lapply(Reference_parts, function(parts) parts[4:6])) %&gt;% mutate(Reference = sapply(Reference_parts, function(x) paste(x, collapse = &quot;_&quot;))) %&gt;% select(-Reference_parts) %&gt;% # Remove the temporary column from the data frame. mutate(Reference = str_remove(Reference, &quot;^Ecoli_&quot;)) üí° Tip: Try to run the code above line by line. 4.1.4 Removing contaminants We remove the contaminant proteins which were present in the fasta file used in the data processing. Contaminant proteins are e.g.¬†keratin from skin or hair that are often accidentally introduced during sample handling. protein_data &lt;- protein_data %&gt;% filter(!str_detect(ProteinName, &quot;CON_&quot;)) üìå Remember: It is always a good idea to check the data often while processing it. head(protein_data, n = 10) ## # A tibble: 10 √ó 3 ## ProteinName Reference Intensity ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 sp|A5A613|YCIY_ECOLI DMSO_rep1 27.2 ## 2 sp|P00350|6PGD_ECOLI DMSO_rep1 28.2 ## 3 sp|P00350|6PGD_ECOLI DMSO_rep2 27.9 ## 4 sp|P00350|6PGD_ECOLI DMSO_rep3 27.7 ## 5 sp|P00350|6PGD_ECOLI DMSO_rep4 27.2 ## 6 sp|P00350|6PGD_ECOLI Suf_rep1 27.4 ## 7 sp|P00350|6PGD_ECOLI Suf_rep2 27.0 ## 8 sp|P00350|6PGD_ECOLI Suf_rep3 27.8 ## 9 sp|P00350|6PGD_ECOLI Suf_rep4 27.6 ## 10 sp|P00363|FRDA_ECOLI DMSO_rep1 30.2 ‚ùì Question: Can you think about a different way of inspecting the data? 4.1.5 Cleaning names Split the ProteinName column into Identifier, Source, ProteinName and Gene columns. After splitting, we also remove the _ECOLI suffix from the Gene column. protein_data_parsed &lt;- protein_data %&gt;% separate(ProteinName, into = c(&quot;Source&quot;, &quot;Protein&quot;, &quot;Gene&quot;), sep = &quot;\\\\|&quot;, extra = &quot;drop&quot;, remove = FALSE) %&gt;% mutate(Gene = str_remove(Gene, &quot;_ECOLI&quot;)) %&gt;% rename(&quot;Identifier&quot; = &quot;ProteinName&quot;) Finally, add a column with the experimental condition labels. protein_data_parsed &lt;- protein_data_parsed %&gt;% mutate(Label = if_else(str_detect(Reference, &quot;DMSO&quot;), &quot;DMSO&quot;, &quot;Sulforaphane&quot;)) Let‚Äôs have a look at the final data frame. head(protein_data_parsed, n = 10) ## # A tibble: 10 √ó 7 ## Identifier Source Protein Gene Reference Intensity Label ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 sp|A5A613|YCIY_ECOLI sp A5A613 YCIY DMSO_rep1 27.2 DMSO ## 2 sp|P00350|6PGD_ECOLI sp P00350 6PGD DMSO_rep1 28.2 DMSO ## 3 sp|P00350|6PGD_ECOLI sp P00350 6PGD DMSO_rep2 27.9 DMSO ## 4 sp|P00350|6PGD_ECOLI sp P00350 6PGD DMSO_rep3 27.7 DMSO ## 5 sp|P00350|6PGD_ECOLI sp P00350 6PGD DMSO_rep4 27.2 DMSO ## 6 sp|P00350|6PGD_ECOLI sp P00350 6PGD Suf_rep1 27.4 Sulforaphane ## 7 sp|P00350|6PGD_ECOLI sp P00350 6PGD Suf_rep2 27.0 Sulforaphane ## 8 sp|P00350|6PGD_ECOLI sp P00350 6PGD Suf_rep3 27.8 Sulforaphane ## 9 sp|P00350|6PGD_ECOLI sp P00350 6PGD Suf_rep4 27.6 Sulforaphane ## 10 sp|P00363|FRDA_ECOLI sp P00363 FRDA DMSO_rep1 30.2 DMSO "],["plot-the-overall-intensity-distributions-per-replicate.html", "4.2 Plot the overall intensity distributions per replicate", " 4.2 Plot the overall intensity distributions per replicate Define colors for the labels. They will be used in multiple plots. label_colors &lt;- c(&quot;DMSO&quot; = &quot;#6a51a3&quot;, &quot;Sulforaphane&quot; = &quot;#2ca25f&quot;) Plotting pipeline: Format Reference names for better readability in the plots Start ggplot, map global aesthetics (x axis and fill color) Add histogram layer with 40 bins and white borders Add labels and titles protein_data_parsed_mut &lt;- protein_data_parsed %&gt;% mutate(Reference = case_when( Reference == &quot;DMSO_rep1&quot; ~ &quot;DMSO 1&quot;, Reference == &quot;DMSO_rep2&quot; ~ &quot;DMSO 2&quot;, Reference == &quot;DMSO_rep3&quot; ~ &quot;DMSO 3&quot;, Reference == &quot;DMSO_rep4&quot; ~ &quot;DMSO 4&quot;, Reference == &quot;Suf_rep1&quot; ~ &quot;Sulforaphane 1&quot;, Reference == &quot;Suf_rep2&quot; ~ &quot;Sulforaphane 2&quot;, Reference == &quot;Suf_rep3&quot; ~ &quot;Sulforaphane 3&quot;, Reference == &quot;Suf_rep4&quot; ~ &quot;Sulforaphane 4&quot;, TRUE ~ Reference )) ggplot(protein_data_parsed_mut, aes(x = Intensity, fill = Label)) + geom_histogram(bins = 40, color = &quot;white&quot;) + labs( title = &quot;Log2-transformed protein intensity distributions&quot;, x = &quot;Log2 [Intensity]&quot;, y = &quot;Count&quot;, fill = &quot;Group&quot; ) + scale_y_continuous(expand = c(0.01, 0)) + theme_minimal() + scale_fill_manual(values = label_colors) + facet_wrap(~Reference, scales = &quot;fixed&quot;, nrow = 2) "],["compute-and-plot-pca-principal-component-analysis.html", "4.3 Compute and plot PCA (Principal Component Analysis)", " 4.3 Compute and plot PCA (Principal Component Analysis) Reshape the data for PCA. pca_data &lt;- protein_data_parsed_mut %&gt;% select(Identifier, Reference, Intensity) %&gt;% pivot_wider(names_from = Identifier, values_from = Intensity) %&gt;% column_to_rownames(var = &quot;Reference&quot;) %&gt;% select(where(~ !any(is.na(.)))) %&gt;% # remove columns with NA values. select(where(~ var(.) &gt; 0)) # remove columns with zero variance. Perform the PCA. pca_result &lt;- prcomp(pca_data, center = TRUE, scale. = TRUE) Get the percentage of variance explained by each principal component. pca_variance &lt;- (pca_result$sdev^2) / sum(pca_result$sdev^2) * 100 Create a data frame for plotting. pca_df &lt;- as.data.frame(pca_result$x) %&gt;% rownames_to_column(var = &quot;Reference&quot;) %&gt;% mutate(Label = if_else(str_detect(Reference, &quot;DMSO&quot;), &quot;DMSO&quot;, &quot;Sulforaphane&quot;)) Take a look at the PCA data frame that will be used for plotting. head(pca_df, n = 10) ## Reference PC1 PC2 PC3 PC4 PC5 ## 1 DMSO 1 -40.5236994 -21.263605 -9.643622 2.0643358 -0.9507316 ## 2 DMSO 2 13.7332455 -13.822736 13.220601 0.9806235 14.0553245 ## 3 DMSO 3 19.8122465 -11.864672 5.863109 -0.0572881 8.2225187 ## 4 DMSO 4 25.4636747 -7.697248 -16.619225 -7.6995175 -18.5430187 ## 5 Sulforaphane 1 -14.1460645 11.793599 19.907967 -21.5451863 -7.3112721 ## 6 Sulforaphane 2 -3.1087881 14.334322 6.820141 17.9491878 -2.2533926 ## 7 Sulforaphane 3 0.4434575 8.669353 2.249586 15.2578529 -10.0897930 ## 8 Sulforaphane 4 -1.6740722 19.850987 -21.798556 -6.9500080 16.8703647 ## PC6 PC7 PC8 Label ## 1 1.258466 -1.05864899 2.506960e-13 DMSO ## 2 -18.934979 -0.02030233 2.459518e-13 DMSO ## 3 22.743865 2.39521208 2.462277e-13 DMSO ## 4 -4.678309 -5.77878509 2.423448e-13 DMSO ## 5 1.097554 0.33856664 2.473822e-13 Sulforaphane ## 6 1.808497 -18.20934008 2.490623e-13 Sulforaphane ## 7 -2.272283 20.13713178 2.485977e-13 Sulforaphane ## 8 -1.022810 2.19616600 2.491229e-13 Sulforaphane Plotting pipeline: Calculate convex hulls for each group (optional). These are used to draw fancy polygons around the groups in the PCA plot. Start ggplot, map global aesthetics (x and y axes, color, and labels) Add points layer Add polygon layer for convex hulls around the groups Add text (point labels) layer Add labels and titles for axes and legend Customize colors for points and polygons Apply minimal theme and further customize it # Calculate convex hulls for each group (optional) hulls &lt;- pca_df %&gt;% group_by(Label) %&gt;% slice(chull(PC1, PC2)) %&gt;% ungroup() ggplot(pca_df, aes(x = PC1, y = PC2, color = Label, label = Reference)) + geom_point(size = 6) + # Draw convex hulls around the groups geom_polygon( data = hulls, aes(x = PC1, y = PC2, fill = Label, color = Label), alpha = 0.15, color = NA, show.legend = FALSE ) + geom_text(vjust = -1.3, hjust = 0.5, size = 3.5, show.legend = FALSE) + labs( title = &quot;Principal component analysis (PCA) of Log2-transformed protein intensities&quot;, x = paste0(&quot;PC1 (&quot;, round(pca_variance[1], 1), &quot;% variance)&quot;), y = paste0(&quot;PC2 (&quot;, round(pca_variance[2], 1), &quot;% variance)&quot;), color = &quot;Group&quot; ) + scale_color_manual(values = label_colors) + scale_fill_manual(values = label_colors) + theme_minimal() + # Further customize the theme theme( axis.text = element_text(size = 12, color = &quot;#666666&quot;), axis.title = element_text(size = 12.5), plot.title = element_text(size = 14, face = &quot;bold&quot;), legend.title = element_text(size = 12), legend.text = element_text(size = 12), legend.position = &quot;right&quot;, panel.grid.minor = element_blank(), panel.border = element_rect(color = &quot;#666666&quot;, fill = NA), axis.ticks = element_line(color = &quot;#666666&quot;) ) "],["identify-and-plot-proteins-with-highest-fold-change-between-conditions.html", "4.4 Identify and plot proteins with highest fold-change between conditions", " 4.4 Identify and plot proteins with highest fold-change between conditions Compute fold changes (Log2FC) between Sulforaphane and DMSO for each protein. fold_changes &lt;- protein_data_parsed %&gt;% group_by(Gene, Label) %&gt;% filter(n() &gt;= 2) %&gt;% # keep only labels with &gt;=2 replicates ungroup() %&gt;% group_by(Gene) %&gt;% filter(n_distinct(Label) == 2) %&gt;% # keep only proteins present in both groups summarize( DMSO = mean(Intensity[Label == &quot;DMSO&quot;], na.rm = TRUE), Sulforaphane = mean(Intensity[Label == &quot;Sulforaphane&quot;], na.rm = TRUE), .groups = &quot;drop&quot; ) %&gt;% mutate( Log2FC = Sulforaphane - DMSO, # already log2-transformed ) %&gt;% # Prepare a column indicating in which condition intensity is higher # This column will be used for faceting the plot later mutate(higher_in = case_when( Log2FC &gt; 0 ~ &quot;Higher in Sulforaphane&quot;, Log2FC &lt; 0 ~ &quot;Higher in DMSO&quot;, TRUE ~ &quot;No change&quot; )) %&gt;% arrange(desc(Log2FC)) Extract top 20 proteins with highest absolute Log2FC in each condition. top_proteins_DMSO &lt;- fold_changes %&gt;% filter(higher_in == &quot;Higher in DMSO&quot;) %&gt;% slice_max(order_by = abs(Log2FC), n = 20) top_proteins_sulforaphane &lt;- fold_changes %&gt;% filter(higher_in == &quot;Higher in Sulforaphane&quot;) %&gt;% slice_max(order_by = abs(Log2FC), n = 20) Combine the top proteins from both conditions into a single data frame. top_proteins_both &lt;- bind_rows(top_proteins_DMSO, top_proteins_sulforaphane) Prepare data for plotting. plot_data_fc &lt;- protein_data_parsed %&gt;% group_by(Gene, Label) %&gt;% summarize( Mean = mean(Intensity, na.rm = TRUE), SD = sd(Intensity, na.rm = TRUE), .groups = &quot;drop&quot; ) %&gt;% # Inner join the current data frame with the top proteins to keep only those inner_join(top_proteins_both[, c(&quot;Gene&quot;, &quot;higher_in&quot;)], by = &quot;Gene&quot;) Take a look at the data to be plotted. head(plot_data_fc, n = 10) ## # A tibble: 10 √ó 5 ## Gene Label Mean SD higher_in ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 ARGR DMSO 26.5 1.86 Higher in DMSO ## 2 ARGR Sulforaphane 24.6 1.30 Higher in DMSO ## 3 ARTJ DMSO 23.3 0.618 Higher in Sulforaphane ## 4 ARTJ Sulforaphane 26.2 1.10 Higher in Sulforaphane ## 5 BAME DMSO 27.1 0.728 Higher in Sulforaphane ## 6 BAME Sulforaphane 28.8 1.11 Higher in Sulforaphane ## 7 BCCP DMSO 27.3 1.60 Higher in Sulforaphane ## 8 BCCP Sulforaphane 29.4 2.76 Higher in Sulforaphane ## 9 CITD DMSO 26.2 2.03 Higher in DMSO ## 10 CITD Sulforaphane 23.6 0.628 Higher in DMSO Plotting pipeline: Start ggplot, map global aesthetics (x and y axes, color, and group) Reorder genes based on their mean intensity for better visualization Add lines connecting the points of the same gene (needs ‚Äògroup‚Äô aesthetic for the correct behavior) Add ‚Äúshadow‚Äù points representing the standard deviation. They should be behind the main points, so add them first. Add points for each condition. Refine size scale for the SD points for better visibility Flip coordinates. What is mapped to x axis goes to y axis and vice versa. ggplot(plot_data_fc, aes(x = reorder(Gene, Mean), y = Mean, color = Label, group = Gene)) + geom_line(color = &quot;#999999&quot;, linewidth = 1, show.legend = FALSE) + geom_point(aes(size = SD), position = position_dodge(width = 0.5), alpha = 0.35, show.legend = TRUE ) + geom_point(position = position_dodge(width = 0.5), size = 4, show.legend = FALSE) + scale_size_continuous(range = c(6, 13), breaks = c(1, 2, 3)) + coord_flip() + labs( title = &quot;Top 20 proteins with highest Log2FC between Sulforaphane and DMSO&quot;, x = &quot;Gene symbol&quot;, y = &quot;Mean Log2 [Intensity]&quot;, size = &quot;Standard deviation&quot;, color = &quot;Group&quot; ) + scale_color_manual(values = label_colors) + theme_minimal() + facet_wrap(~higher_in, scales = &quot;free_y&quot;, nrow = 1) + guides(color = guide_legend( override.aes = list(size = 5, alpha = 1) )) ‚ùì Question: How does the plot look like if you remove geom_ layers one by one? "],["extra.html", "5 Extra", " 5 Extra geoms &lt;- list( geom_point(), geom_boxplot(aes(group = cut_width(displ, 1))), list(geom_point(), geom_smooth()) ) p &lt;- ggplot(mpg, aes(displ, hwy)) lapply(geoms, function(g) p + g) ## [[1]] ## ## [[2]] ## ## [[3]] ## `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39; Exercises How could you add a geom_point() layer to each element of the following list? plots &lt;- list( ggplot(mpg, aes(displ, hwy)), ggplot(diamonds, aes(carat, price)), ggplot(faithfuld, aes(waiting, eruptions, size = density)) ) What does the following function do? What‚Äôs a better name for it? mystery &lt;- function(...) { Reduce(`+`, list(...), accumulate = TRUE) } mystery( ggplot(mpg, aes(displ, hwy)) + geom_point(), geom_smooth(), xlab(NULL), ylab(NULL) ) ## [[1]] ## ## [[2]] ## `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39; ## ## [[3]] ## `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39; ## ## [[4]] ## `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39; https://ggplot2-book.org/maps.html "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
