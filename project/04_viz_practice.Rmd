# For Advanced

Here we will use the `tidyverse` package to transform, clean, and visualize the proteomics data, producing high-quality, publication-ready figures throughout the analysis.

## Data preparation


### Loading the raw proteomics data

<div class="remember">
  <strong>üìå Remember:</strong> Load the library before starting the analysis.
</div>

``` {r install_packages2, message=FALSE, echo=TRUE}
library(tidyverse)
```

<br/>

Load and prepare the data.

`read_csv()` from `readr` package (part of `tidyverse`) is used to read csv files.

``` {r}
data <- read_csv("../data-01/PXD040621_peptides.csv", show_col_types = FALSE)
```

<br/>

<div class="remember">
  <strong>üìå Remember:</strong> Remember: You can use the `DT` package to visualize the data.
</div>

```{r}
DT::datatable(
    data = head(data, 1000), # show only the first 1000 rows
    rownames = FALSE,
    extensions = c("Buttons", "Scroller"),
    options = list(
        dom = "Bfrtip",
        buttons = c("copy", "csv"),
        deferRender = TRUE,
        scrollX = TRUE,
        scrollY = 200,
        scroller = TRUE
    ),
    caption = "proteomics metadata"
)
```

<br/>

### Data transformation

`log2` transformations are commonly used for log-normal distributed data.

``` {r}
data <- data %>%
    mutate(Intensity = log2(Intensity))
```

<div class="question">
  <strong>‚ùì Question:</strong> Do you remember what the `%>%` (pipe) is doing in the code?
</div>


### Data aggregation

Let's aggregate the peptide intensities to protein intensities.
We use the median of the peptide intensities for each protein.
Also, let's shorten sample names for better readability.

``` {r}
protein_data <- data %>%
    group_by(ProteinName, Reference) %>%
    summarize(Intensity = median(Intensity, na.rm = TRUE), .groups = "drop") %>%
    # Small pipeline to shorten Reference names
    mutate(Reference_parts = strsplit(Reference, "_")) %>%
    mutate(Reference_parts = lapply(Reference_parts, function(parts) parts[4:6])) %>%
    mutate(Reference = sapply(Reference_parts, function(x) paste(x, collapse = "_"))) %>%
    select(-Reference_parts) %>% # Remove the temporary column from the data frame.
    mutate(Reference = str_remove(Reference, "^Ecoli_"))
```


<div class="tip">
<strong>üí° Tip:</strong> Try to run the code above line by line.
</div>

### Removing contaminants

We remove the contaminant proteins which were present in the fasta file used in the data processing.

Contaminant proteins are e.g. keratin from skin or hair that are often accidentally introduced
during sample handling.

``` {r}
protein_data <- protein_data %>%
    filter(!str_detect(ProteinName, "CON_"))
```

<br/>

<div class="remember">
  <strong>üìå Remember:</strong> It is always a good idea to check the data often while processing it.
</div>

```{r}
head(protein_data, n = 10)
```


<div class="question">
  <strong>‚ùì Question:</strong> Can you think about a different way of inspecting the data?</div>

### Cleaning names

Split the `ProteinName` column into `Identifier`, `Source`, `ProteinName` and `Gene` columns.

After splitting, we also remove the `_ECOLI` suffix from the `Gene` column.

``` {r}
protein_data_parsed <- protein_data %>%
    separate(ProteinName, into = c("Source", "Protein", "Gene"), sep = "\\|", extra = "drop", remove = FALSE) %>%
    mutate(Gene = str_remove(Gene, "_ECOLI")) %>%
    rename("Identifier" = "ProteinName")
```

<br/>

Finally, add a column with the experimental condition labels.

```{r}
protein_data_parsed <- protein_data_parsed %>%
    mutate(Label = if_else(str_detect(Reference, "DMSO"), "DMSO", "Sulforaphane"))
```

<br/>

Let's have a look at the final data frame.

```{r}
head(protein_data_parsed, n = 10)
```


## Plot the overall intensity distributions per replicate

Define colors for the labels. They will be used in multiple plots.

```{r}
label_colors <- c("DMSO" = "#6a51a3", "Sulforaphane" = "#2ca25f")
```

<br/>

Plotting pipeline:

1. Format Reference names for better readability in the plots

2. Start ggplot, map global aesthetics (x axis and fill color)

3. Add histogram layer with 40 bins and white borders

4. Add labels and titles

```{r}
protein_data_parsed_mut <- protein_data_parsed %>%
    mutate(Reference = case_when(
        Reference == "DMSO_rep1" ~ "DMSO 1",
        Reference == "DMSO_rep2" ~ "DMSO 2",
        Reference == "DMSO_rep3" ~ "DMSO 3",
        Reference == "DMSO_rep4" ~ "DMSO 4",
        Reference == "Suf_rep1" ~ "Sulforaphane 1",
        Reference == "Suf_rep2" ~ "Sulforaphane 2",
        Reference == "Suf_rep3" ~ "Sulforaphane 3",
        Reference == "Suf_rep4" ~ "Sulforaphane 4",
        TRUE ~ Reference
    ))
```


```{r, echo=TRUE, fig.width=10, fig.height=6}
ggplot(protein_data_parsed_mut, aes(x = Intensity, fill = Label)) +
    geom_histogram(bins = 40, color = "white") +
    labs(
        title = "Log2-transformed protein intensity distributions",
        x = "Log2 [Intensity]",
        y = "Count",
        fill = "Group"
    ) +
    scale_y_continuous(expand = c(0.01, 0)) +
    theme_minimal() +
    scale_fill_manual(values = label_colors) +
    facet_wrap(~Reference, scales = "fixed", nrow = 2)
```



## Compute and plot PCA (Principal Component Analysis)


Reshape the data for PCA.

```{r}
pca_data <- protein_data_parsed_mut %>%
    select(Identifier, Reference, Intensity) %>%
    pivot_wider(names_from = Identifier, values_from = Intensity) %>%
    column_to_rownames(var = "Reference") %>%
    select(where(~ !any(is.na(.)))) %>% # remove columns with NA values.
    select(where(~ var(.) > 0)) # remove columns with zero variance.
```

<br/>

Perform the PCA.


```{r}
pca_result <- prcomp(pca_data, center = TRUE, scale. = TRUE)
```

<br/>

Get the percentage of variance explained by each principal component.


```{r}
pca_variance <- (pca_result$sdev^2) / sum(pca_result$sdev^2) * 100
```

<br/>

Create a data frame for plotting.

```{r}
pca_df <- as.data.frame(pca_result$x) %>%
    rownames_to_column(var = "Reference") %>%
    mutate(Label = if_else(str_detect(Reference, "DMSO"), "DMSO", "Sulforaphane"))
```

<br/>

Take a look at the PCA data frame that will be used for plotting.

```{r}
head(pca_df, n = 10)
```

<br/>

Plotting pipeline:

1. Calculate convex hulls for each group (optional).
These are used to draw fancy polygons around the groups in the PCA plot.

2. Start ggplot, map global aesthetics (x and y axes, color, and labels)

3. Add points layer

4. Add polygon layer for convex hulls around the groups

5. Add text (point labels) layer

6. Add labels and titles for axes and legend

7. Customize colors for points and polygons

8. Apply minimal theme and further customize it


```{r}
# Calculate convex  hulls for each group (optional)
hulls <- pca_df %>%
    group_by(Label) %>%
    slice(chull(PC1, PC2)) %>%
    ungroup()
```

```{r, echo=TRUE, fig.width=10, fig.height=8}
ggplot(pca_df, aes(x = PC1, y = PC2, color = Label, label = Reference)) +
    geom_point(size = 6) +
    # Draw convex hulls around the groups
    geom_polygon(
        data = hulls, aes(x = PC1, y = PC2, fill = Label, color = Label),
        alpha = 0.15, color = NA, show.legend = FALSE
    ) +
    geom_text(vjust = -1.3, hjust = 0.5, size = 3.5, show.legend = FALSE) +
    labs(
        title = "Principal component analysis (PCA) of Log2-transformed protein intensities",
        x = paste0("PC1 (", round(pca_variance[1], 1), "% variance)"),
        y = paste0("PC2 (", round(pca_variance[2], 1), "% variance)"),
        color = "Group"
    ) +
    scale_color_manual(values = label_colors) +
    scale_fill_manual(values = label_colors) +
    theme_minimal() +
    # Further customize the theme
    theme(
        axis.text = element_text(size = 12, color = "#666666"),
        axis.title = element_text(size = 12.5),
        plot.title = element_text(size = 14, face = "bold"),
        legend.title = element_text(size = 12),
        legend.text = element_text(size = 12),
        legend.position = "right",
        panel.grid.minor = element_blank(),
        panel.border = element_rect(color = "#666666", fill = NA),
        axis.ticks = element_line(color = "#666666")
    )
```


## Identify and plot proteins with highest fold-change between conditions

Compute fold changes (Log2FC) between Sulforaphane and DMSO for each protein.

```{r}
fold_changes <- protein_data_parsed %>%
    group_by(Gene, Label) %>%
    filter(n() >= 2) %>% # keep only labels with >=2 replicates
    ungroup() %>%
    group_by(Gene) %>%
    filter(n_distinct(Label) == 2) %>% # keep only proteins present in both groups
    summarize(
        DMSO = mean(Intensity[Label == "DMSO"], na.rm = TRUE),
        Sulforaphane = mean(Intensity[Label == "Sulforaphane"], na.rm = TRUE),
        .groups = "drop"
    ) %>%
    mutate(
        Log2FC = Sulforaphane - DMSO, # already log2-transformed
    ) %>%
    # Prepare a column indicating in which condition intensity is higher
    # This column will be used for faceting the plot later
    mutate(higher_in = case_when(
        Log2FC > 0 ~ "Higher in Sulforaphane",
        Log2FC < 0 ~ "Higher in DMSO",
        TRUE ~ "No change"
    )) %>%
    arrange(desc(Log2FC))
```

<br/>

Extract top 20 proteins with highest absolute Log2FC in each condition.

```{r}
top_proteins_DMSO <- fold_changes %>%
    filter(higher_in == "Higher in DMSO") %>%
    slice_max(order_by = abs(Log2FC), n = 20)
```


```{r}
top_proteins_sulforaphane <- fold_changes %>%
    filter(higher_in == "Higher in Sulforaphane") %>%
    slice_max(order_by = abs(Log2FC), n = 20)
```

<br/>

Combine the top proteins from both conditions into a single data frame.

```{r}
top_proteins_both <- bind_rows(top_proteins_DMSO, top_proteins_sulforaphane)
```

<br/>

Prepare data for plotting.

```{r}
plot_data_fc <- protein_data_parsed %>%
    group_by(Gene, Label) %>%
    summarize(
        Mean = mean(Intensity, na.rm = TRUE),
        SD = sd(Intensity, na.rm = TRUE),
        .groups = "drop"
    ) %>%
    # Inner join the current data frame with the top proteins to keep only those
    inner_join(top_proteins_both[, c("Gene", "higher_in")], by = "Gene")
```

<br/>

Take a look at the data to be plotted.
```{r}
head(plot_data_fc, n = 10)
```

<br/>

Plotting pipeline:

1. Start ggplot, map global aesthetics (x and y axes, color, and group)

2. Reorder genes based on their mean intensity for better visualization

3. Add lines connecting the points of the same gene
    (needs 'group' aesthetic for the correct behavior)

4. Add "shadow" points representing the standard deviation.
    They should be behind the main points, so add them first.

5. Add points for each condition.

6. Refine size scale for the SD points for better visibility

7. Flip coordinates. What is mapped to x axis goes to y axis and vice versa.


```{r, echo=TRUE, fig.width=13, fig.height=10}
ggplot(plot_data_fc, aes(x = reorder(Gene, Mean), y = Mean, color = Label, group = Gene)) +
    geom_line(color = "#999999", linewidth = 1, show.legend = FALSE) +
    geom_point(aes(size = SD),
        position = position_dodge(width = 0.5), alpha = 0.35,
        show.legend = TRUE
    ) +
    geom_point(position = position_dodge(width = 0.5), size = 4, show.legend = FALSE) +
    scale_size_continuous(range = c(6, 13), breaks = c(1, 2, 3)) +
    coord_flip() +
    labs(
        title = "Top 20 proteins with highest Log2FC between Sulforaphane and DMSO",
        x = "Gene symbol",
        y = "Mean Log2 [Intensity]",
        size = "Standard deviation",
        color = "Group"
    ) +
    scale_color_manual(values = label_colors) +
    theme_minimal() +
    facet_wrap(~higher_in, scales = "free_y", nrow = 1) +
    guides(color = guide_legend(
        override.aes = list(size = 5, alpha = 1)
    ))
```

<div class="question">
  <strong>‚ùì Question:</strong> How does the plot look like if you remove `geom_` layers one by one?
</div>

